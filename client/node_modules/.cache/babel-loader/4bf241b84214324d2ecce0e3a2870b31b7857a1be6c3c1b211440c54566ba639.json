{"ast":null,"code":"import { db } from '../firebase';\nimport { collection, getDocs, doc, getDoc, addDoc, updateDoc, query, where } from 'firebase/firestore';\n\n// Récupérer toutes les soumissions de formulaire\nexport const getAllFormSubmissions = async () => {\n  try {\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const submissionsSnapshot = await getDocs(submissionsCollection);\n    const submissionsList = submissionsSnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n\n    // Mettre à jour les soumissions sans statut\n    for (const submission of submissionsList) {\n      if (!submission.status) {\n        await updateFormSubmissionStatus(submission.id, 'pending');\n        submission.status = 'pending';\n      }\n    }\n    return submissionsList;\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération des soumissions:\", error);\n    return [];\n  }\n};\n\n// Récupérer les soumissions en attente\nexport const getPendingFormSubmissions = async () => {\n  try {\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const q = query(submissionsCollection, where(\"status\", \"==\", \"pending\"));\n    const submissionsSnapshot = await getDocs(q);\n    return submissionsSnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération des soumissions en attente:\", error);\n    return [];\n  }\n};\n\n// Récupérer une soumission par ID\nexport const getFormSubmissionById = async id => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    const submissionSnapshot = await getDoc(submissionDoc);\n    if (submissionSnapshot.exists()) {\n      return {\n        id: submissionSnapshot.id,\n        ...submissionSnapshot.data()\n      };\n    } else {\n      console.log(\"Aucune soumission trouvée avec cet ID\");\n      return null;\n    }\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération de la soumission:\", error);\n    return null;\n  }\n};\n\n// Créer une nouvelle soumission de formulaire\nexport const createFormSubmission = async formData => {\n  try {\n    // S'assurer que le statut est défini\n    const dataWithStatus = {\n      ...formData,\n      status: formData.status || 'pending',\n      createdAt: new Date()\n    };\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const docRef = await addDoc(submissionsCollection, dataWithStatus);\n    return {\n      id: docRef.id,\n      ...dataWithStatus\n    };\n  } catch (error) {\n    console.error(\"Erreur lors de la création de la soumission:\", error);\n    throw error;\n  }\n};\n\n// Mettre à jour le statut d'une soumission\nexport const updateFormSubmissionStatus = async (id, status) => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    await updateDoc(submissionDoc, {\n      status\n    });\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour du statut:\", error);\n    return false;\n  }\n};\n\n// Mettre à jour une soumission avec les données validées\nexport const updateFormSubmissionWithValidatedData = async (id, validatedData) => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    await updateDoc(submissionDoc, {\n      ...validatedData,\n      status: 'validated',\n      validatedAt: new Date()\n    });\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour des données validées:\", error);\n    return false;\n  }\n};\n\n// Mettre à jour les entités liées via le token commun\nexport const updateLinkedEntities = async (commonToken, validatedData) => {\n  try {\n    // Rechercher toutes les soumissions avec ce token commun\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const q = query(submissionsCollection, where(\"commonToken\", \"==\", commonToken));\n    const submissionsSnapshot = await getDocs(q);\n\n    // Mettre à jour chaque soumission\n    const updatePromises = submissionsSnapshot.docs.map(async submission => {\n      const submissionDoc = doc(db, 'formSubmissions', submission.id);\n      await updateDoc(submissionDoc, {\n        ...validatedData,\n        status: 'validated',\n        validatedAt: new Date()\n      });\n    });\n    await Promise.all(updatePromises);\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour des entités liées:\", error);\n    return false;\n  }\n};","map":{"version":3,"names":["db","collection","getDocs","doc","getDoc","addDoc","updateDoc","query","where","getAllFormSubmissions","submissionsCollection","submissionsSnapshot","submissionsList","docs","map","id","data","submission","status","updateFormSubmissionStatus","error","console","getPendingFormSubmissions","q","getFormSubmissionById","submissionDoc","submissionSnapshot","exists","log","createFormSubmission","formData","dataWithStatus","createdAt","Date","docRef","updateFormSubmissionWithValidatedData","validatedData","validatedAt","updateLinkedEntities","commonToken","updatePromises","Promise","all"],"sources":["/workspaces/app-booking/client/src/services/formSubmissionsService.js"],"sourcesContent":["import { db } from '../firebase';\nimport { collection, getDocs, doc, getDoc, addDoc, updateDoc, query, where } from 'firebase/firestore';\n\n// Récupérer toutes les soumissions de formulaire\nexport const getAllFormSubmissions = async () => {\n  try {\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const submissionsSnapshot = await getDocs(submissionsCollection);\n    const submissionsList = submissionsSnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    // Mettre à jour les soumissions sans statut\n    for (const submission of submissionsList) {\n      if (!submission.status) {\n        await updateFormSubmissionStatus(submission.id, 'pending');\n        submission.status = 'pending';\n      }\n    }\n    \n    return submissionsList;\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération des soumissions:\", error);\n    return [];\n  }\n};\n\n// Récupérer les soumissions en attente\nexport const getPendingFormSubmissions = async () => {\n  try {\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const q = query(submissionsCollection, where(\"status\", \"==\", \"pending\"));\n    const submissionsSnapshot = await getDocs(q);\n    return submissionsSnapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération des soumissions en attente:\", error);\n    return [];\n  }\n};\n\n// Récupérer une soumission par ID\nexport const getFormSubmissionById = async (id) => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    const submissionSnapshot = await getDoc(submissionDoc);\n    \n    if (submissionSnapshot.exists()) {\n      return {\n        id: submissionSnapshot.id,\n        ...submissionSnapshot.data()\n      };\n    } else {\n      console.log(\"Aucune soumission trouvée avec cet ID\");\n      return null;\n    }\n  } catch (error) {\n    console.error(\"Erreur lors de la récupération de la soumission:\", error);\n    return null;\n  }\n};\n\n// Créer une nouvelle soumission de formulaire\nexport const createFormSubmission = async (formData) => {\n  try {\n    // S'assurer que le statut est défini\n    const dataWithStatus = {\n      ...formData,\n      status: formData.status || 'pending',\n      createdAt: new Date()\n    };\n    \n    const submissionsCollection = collection(db, 'formSubmissions');\n    const docRef = await addDoc(submissionsCollection, dataWithStatus);\n    \n    return {\n      id: docRef.id,\n      ...dataWithStatus\n    };\n  } catch (error) {\n    console.error(\"Erreur lors de la création de la soumission:\", error);\n    throw error;\n  }\n};\n\n// Mettre à jour le statut d'une soumission\nexport const updateFormSubmissionStatus = async (id, status) => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    await updateDoc(submissionDoc, { status });\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour du statut:\", error);\n    return false;\n  }\n};\n\n// Mettre à jour une soumission avec les données validées\nexport const updateFormSubmissionWithValidatedData = async (id, validatedData) => {\n  try {\n    const submissionDoc = doc(db, 'formSubmissions', id);\n    await updateDoc(submissionDoc, { \n      ...validatedData,\n      status: 'validated',\n      validatedAt: new Date()\n    });\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour des données validées:\", error);\n    return false;\n  }\n};\n\n// Mettre à jour les entités liées via le token commun\nexport const updateLinkedEntities = async (commonToken, validatedData) => {\n  try {\n    // Rechercher toutes les soumissions avec ce token commun\n    const submissionsCollection = collection(db, 'formSubmissions');\n    const q = query(submissionsCollection, where(\"commonToken\", \"==\", commonToken));\n    const submissionsSnapshot = await getDocs(q);\n    \n    // Mettre à jour chaque soumission\n    const updatePromises = submissionsSnapshot.docs.map(async (submission) => {\n      const submissionDoc = doc(db, 'formSubmissions', submission.id);\n      await updateDoc(submissionDoc, { \n        ...validatedData,\n        status: 'validated',\n        validatedAt: new Date()\n      });\n    });\n    \n    await Promise.all(updatePromises);\n    return true;\n  } catch (error) {\n    console.error(\"Erreur lors de la mise à jour des entités liées:\", error);\n    return false;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}