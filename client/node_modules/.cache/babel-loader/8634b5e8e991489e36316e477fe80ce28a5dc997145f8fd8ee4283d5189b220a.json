{"ast":null,"code":"import { collection, getDocs, getDoc, doc, addDoc, updateDoc, deleteDoc, query, orderBy, where, setDoc, Timestamp } from 'firebase/firestore';\nimport { db } from '../firebase';\n\n// Collection de référence\nconst CONCERTS_COLLECTION = 'concerts';\n\n// Assurez-vous que la collection concerts existe\nconst concertsCollection = collection(db, CONCERTS_COLLECTION);\n\n/**\n * Récupère tous les concerts\n * @param {Object} filters - Filtres à appliquer (optionnel)\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcerts = async (filters = {}) => {\n  try {\n    console.log(\"[getConcerts] Tentative de récupération des concerts depuis Firebase...\");\n    console.log(\"[getConcerts] Filtres appliqués:\", filters);\n\n    // Création d'une requête de base\n    let concertsQuery = concertsCollection;\n\n    // Application des filtres si nécessaire\n    if (filters) {\n      // Filtrer par programmateur\n      if (filters.programmerId) {\n        concertsQuery = query(concertsQuery, where('programmerId', '==', filters.programmerId));\n      }\n\n      // Filtrer par artiste\n      if (filters.artistId) {\n        concertsQuery = query(concertsQuery, where('artistId', '==', filters.artistId));\n      }\n\n      // Filtrer par lieu\n      if (filters.venue) {\n        concertsQuery = query(concertsQuery, where('venue', '==', filters.venue));\n      }\n\n      // Filtrer par token commun\n      if (filters.commonToken) {\n        concertsQuery = query(concertsQuery, where('commonToken', '==', filters.commonToken));\n      }\n    }\n\n    // Ajout d'un tri par date (du plus récent au plus ancien)\n    concertsQuery = query(concertsQuery, orderBy('date', 'desc'));\n\n    // Exécution de la requête\n    const snapshot = await getDocs(concertsQuery);\n    const concerts = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data(),\n      // Convertir les timestamps en objets Date pour faciliter l'utilisation\n      date: doc.data().date ? new Date(doc.data().date.seconds * 1000) : null\n    }));\n    console.log(`[getConcerts] ${concerts.length} concerts récupérés depuis Firebase`);\n    return concerts;\n  } catch (error) {\n    console.error(\"[getConcerts] Erreur lors de la récupération des concerts:\", error);\n    throw error;\n  }\n};\n\n/**\n * Récupère un concert par son ID\n * @param {string} id - ID du concert\n * @returns {Promise<Object>} Données du concert\n */\nexport const getConcertById = async id => {\n  try {\n    console.log(`[getConcertById] Tentative de récupération du concert ${id} depuis Firebase...`);\n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    const snapshot = await getDoc(docRef);\n    if (snapshot.exists()) {\n      const concertData = {\n        id: snapshot.id,\n        ...snapshot.data(),\n        // Convertir les timestamps en objets Date pour faciliter l'utilisation\n        date: snapshot.data().date ? new Date(snapshot.data().date.seconds * 1000) : null\n      };\n      console.log(`[getConcertById] Concert ${id} récupéré depuis Firebase`);\n      return concertData;\n    }\n    console.log(`[getConcertById] Concert ${id} non trouvé dans Firebase`);\n    return null;\n  } catch (error) {\n    console.error(`[getConcertById] Erreur lors de la récupération du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Ajoute un nouveau concert\n * @param {Object} concertData - Données du concert\n * @returns {Promise<Object>} Concert créé avec ID\n */\nexport const addConcert = async concertData => {\n  try {\n    console.log(\"[addConcert] Tentative d'ajout d'un concert à Firebase:\", concertData);\n\n    // Convertir la date en Timestamp si elle existe\n    const dataToAdd = {\n      ...concertData,\n      date: concertData.date ? Timestamp.fromDate(new Date(concertData.date)) : null\n    };\n    const docRef = await addDoc(concertsCollection, dataToAdd);\n    console.log(`[addConcert] Concert ajouté avec succès, ID: ${docRef.id}`);\n    return {\n      id: docRef.id,\n      ...concertData\n    };\n  } catch (error) {\n    console.error(\"[addConcert] Erreur lors de l'ajout du concert:\", error);\n    throw error;\n  }\n};\n\n/**\n * Met à jour un concert existant\n * @param {string} id - ID du concert\n * @param {Object} concertData - Nouvelles données du concert\n * @returns {Promise<Object>} Concert mis à jour\n */\nexport const updateConcert = async (id, concertData) => {\n  try {\n    console.log(`[updateConcert] Tentative de mise à jour du concert ${id}:`, concertData);\n\n    // Convertir la date en Timestamp si elle existe\n    const dataToUpdate = {\n      ...concertData\n    };\n    if (concertData.date) {\n      dataToUpdate.date = concertData.date instanceof Date ? Timestamp.fromDate(concertData.date) : Timestamp.fromDate(new Date(concertData.date));\n    }\n\n    // Vérifier si le concert existe déjà\n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    const docSnap = await getDoc(docRef);\n    if (docSnap.exists()) {\n      // Mettre à jour le concert existant\n      await updateDoc(docRef, dataToUpdate);\n      console.log(`[updateConcert] Concert ${id} mis à jour avec succès`);\n    } else {\n      // Créer un nouveau concert avec l'ID spécifié\n      await setDoc(docRef, dataToUpdate);\n      console.log(`[updateConcert] Nouveau concert créé avec ID spécifié: ${id}`);\n    }\n    return {\n      id,\n      ...concertData\n    };\n  } catch (error) {\n    console.error(`[updateConcert] Erreur lors de la mise à jour du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Supprime un concert\n * @param {string} id - ID du concert\n * @returns {Promise<boolean>} Succès de la suppression\n */\nexport const deleteConcert = async id => {\n  try {\n    console.log(`[deleteConcert] Tentative de suppression du concert ${id}`);\n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    await deleteDoc(docRef);\n    console.log(`[deleteConcert] Concert ${id} supprimé avec succès`);\n    return true;\n  } catch (error) {\n    console.error(`[deleteConcert] Erreur lors de la suppression du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Récupère les concerts par token commun\n * @param {string} commonToken - Token commun\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcertsByToken = async commonToken => {\n  return getConcerts({\n    commonToken\n  });\n};\n\n/**\n * Récupère les concerts par artiste\n * @param {string} artistId - ID de l'artiste\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcertsByArtist = async artistId => {\n  return getConcerts({\n    artistId\n  });\n};","map":{"version":3,"names":["collection","getDocs","getDoc","doc","addDoc","updateDoc","deleteDoc","query","orderBy","where","setDoc","Timestamp","db","CONCERTS_COLLECTION","concertsCollection","getConcerts","filters","console","log","concertsQuery","programmerId","artistId","venue","commonToken","snapshot","concerts","docs","map","id","data","date","Date","seconds","length","error","getConcertById","docRef","exists","concertData","addConcert","dataToAdd","fromDate","updateConcert","dataToUpdate","docSnap","deleteConcert","getConcertsByToken","getConcertsByArtist"],"sources":["/workspaces/app-booking/client/src/services/concertsService.js"],"sourcesContent":["import { \n  collection, \n  getDocs, \n  getDoc, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc,\n  query,\n  orderBy,\n  where,\n  setDoc,\n  Timestamp\n} from 'firebase/firestore';\nimport { db } from '../firebase';\n\n// Collection de référence\nconst CONCERTS_COLLECTION = 'concerts';\n\n// Assurez-vous que la collection concerts existe\nconst concertsCollection = collection(db, CONCERTS_COLLECTION);\n\n/**\n * Récupère tous les concerts\n * @param {Object} filters - Filtres à appliquer (optionnel)\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcerts = async (filters = {}) => {\n  try {\n    console.log(\"[getConcerts] Tentative de récupération des concerts depuis Firebase...\");\n    console.log(\"[getConcerts] Filtres appliqués:\", filters);\n    \n    // Création d'une requête de base\n    let concertsQuery = concertsCollection;\n    \n    // Application des filtres si nécessaire\n    if (filters) {\n      // Filtrer par programmateur\n      if (filters.programmerId) {\n        concertsQuery = query(concertsQuery, where('programmerId', '==', filters.programmerId));\n      }\n      \n      // Filtrer par artiste\n      if (filters.artistId) {\n        concertsQuery = query(concertsQuery, where('artistId', '==', filters.artistId));\n      }\n      \n      // Filtrer par lieu\n      if (filters.venue) {\n        concertsQuery = query(concertsQuery, where('venue', '==', filters.venue));\n      }\n      \n      // Filtrer par token commun\n      if (filters.commonToken) {\n        concertsQuery = query(concertsQuery, where('commonToken', '==', filters.commonToken));\n      }\n    }\n    \n    // Ajout d'un tri par date (du plus récent au plus ancien)\n    concertsQuery = query(concertsQuery, orderBy('date', 'desc'));\n    \n    // Exécution de la requête\n    const snapshot = await getDocs(concertsQuery);\n    \n    const concerts = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data(),\n      // Convertir les timestamps en objets Date pour faciliter l'utilisation\n      date: doc.data().date ? new Date(doc.data().date.seconds * 1000) : null\n    }));\n    \n    console.log(`[getConcerts] ${concerts.length} concerts récupérés depuis Firebase`);\n    return concerts;\n  } catch (error) {\n    console.error(\"[getConcerts] Erreur lors de la récupération des concerts:\", error);\n    throw error;\n  }\n};\n\n/**\n * Récupère un concert par son ID\n * @param {string} id - ID du concert\n * @returns {Promise<Object>} Données du concert\n */\nexport const getConcertById = async (id) => {\n  try {\n    console.log(`[getConcertById] Tentative de récupération du concert ${id} depuis Firebase...`);\n    \n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    const snapshot = await getDoc(docRef);\n    \n    if (snapshot.exists()) {\n      const concertData = {\n        id: snapshot.id,\n        ...snapshot.data(),\n        // Convertir les timestamps en objets Date pour faciliter l'utilisation\n        date: snapshot.data().date ? new Date(snapshot.data().date.seconds * 1000) : null\n      };\n      console.log(`[getConcertById] Concert ${id} récupéré depuis Firebase`);\n      return concertData;\n    }\n    \n    console.log(`[getConcertById] Concert ${id} non trouvé dans Firebase`);\n    return null;\n  } catch (error) {\n    console.error(`[getConcertById] Erreur lors de la récupération du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Ajoute un nouveau concert\n * @param {Object} concertData - Données du concert\n * @returns {Promise<Object>} Concert créé avec ID\n */\nexport const addConcert = async (concertData) => {\n  try {\n    console.log(\"[addConcert] Tentative d'ajout d'un concert à Firebase:\", concertData);\n    \n    // Convertir la date en Timestamp si elle existe\n    const dataToAdd = {\n      ...concertData,\n      date: concertData.date ? Timestamp.fromDate(new Date(concertData.date)) : null\n    };\n    \n    const docRef = await addDoc(concertsCollection, dataToAdd);\n    console.log(`[addConcert] Concert ajouté avec succès, ID: ${docRef.id}`);\n    \n    return {\n      id: docRef.id,\n      ...concertData\n    };\n  } catch (error) {\n    console.error(\"[addConcert] Erreur lors de l'ajout du concert:\", error);\n    throw error;\n  }\n};\n\n/**\n * Met à jour un concert existant\n * @param {string} id - ID du concert\n * @param {Object} concertData - Nouvelles données du concert\n * @returns {Promise<Object>} Concert mis à jour\n */\nexport const updateConcert = async (id, concertData) => {\n  try {\n    console.log(`[updateConcert] Tentative de mise à jour du concert ${id}:`, concertData);\n    \n    // Convertir la date en Timestamp si elle existe\n    const dataToUpdate = {\n      ...concertData\n    };\n    \n    if (concertData.date) {\n      dataToUpdate.date = concertData.date instanceof Date ? \n        Timestamp.fromDate(concertData.date) : \n        Timestamp.fromDate(new Date(concertData.date));\n    }\n    \n    // Vérifier si le concert existe déjà\n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    const docSnap = await getDoc(docRef);\n    \n    if (docSnap.exists()) {\n      // Mettre à jour le concert existant\n      await updateDoc(docRef, dataToUpdate);\n      console.log(`[updateConcert] Concert ${id} mis à jour avec succès`);\n    } else {\n      // Créer un nouveau concert avec l'ID spécifié\n      await setDoc(docRef, dataToUpdate);\n      console.log(`[updateConcert] Nouveau concert créé avec ID spécifié: ${id}`);\n    }\n    \n    return {\n      id,\n      ...concertData\n    };\n  } catch (error) {\n    console.error(`[updateConcert] Erreur lors de la mise à jour du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Supprime un concert\n * @param {string} id - ID du concert\n * @returns {Promise<boolean>} Succès de la suppression\n */\nexport const deleteConcert = async (id) => {\n  try {\n    console.log(`[deleteConcert] Tentative de suppression du concert ${id}`);\n    \n    const docRef = doc(db, CONCERTS_COLLECTION, id);\n    await deleteDoc(docRef);\n    \n    console.log(`[deleteConcert] Concert ${id} supprimé avec succès`);\n    return true;\n  } catch (error) {\n    console.error(`[deleteConcert] Erreur lors de la suppression du concert ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Récupère les concerts par token commun\n * @param {string} commonToken - Token commun\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcertsByToken = async (commonToken) => {\n  return getConcerts({ commonToken });\n};\n\n/**\n * Récupère les concerts par artiste\n * @param {string} artistId - ID de l'artiste\n * @returns {Promise<Array>} Liste des concerts\n */\nexport const getConcertsByArtist = async (artistId) => {\n  return getConcerts({ artistId });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}