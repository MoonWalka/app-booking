{"ast":null,"code":"import{collection,getDocs,getDoc,doc,addDoc,updateDoc,deleteDoc,query,orderBy,where,setDoc,Timestamp,limit}from'firebase/firestore';import{db}from'../firebase';// Collection de référence\nconst FORM_SUBMISSIONS_COLLECTION='formSubmissions';// Assurez-vous que la collection existe\nconst ensureCollection=async collectionName=>{try{console.log(`[ensureCollection] Vérification de la collection ${collectionName}...`);// Vérifier si la collection existe en essayant de récupérer des documents\nconst collectionRef=collection(db,collectionName);const snapshot=await getDocs(query(collectionRef,limit(1)));console.log(`[ensureCollection] Résultat de la vérification: ${snapshot.empty?'collection vide':snapshot.size+' documents trouvés'}`);return true;}catch(error){console.error(`[ensureCollection] Erreur lors de la vérification de la collection ${collectionName}:`,error);return false;}};// Assurez-vous que la collection formSubmissions existe\nconst formSubmissionsCollection=collection(db,FORM_SUBMISSIONS_COLLECTION);/**\n * Récupère tous les formulaires soumis\n * @param {Object} filters - Filtres à appliquer (optionnel)\n * @returns {Promise<Array>} Liste des formulaires soumis\n */export const getFormSubmissions=async function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};try{// S'assurer que la collection existe\nawait ensureCollection(FORM_SUBMISSIONS_COLLECTION);console.log(\"[getFormSubmissions] Tentative de récupération des formulaires depuis Firebase...\");console.log(\"[getFormSubmissions] Filtres appliqués:\",filters);// Vérifier et mettre à jour les soumissions sans statut\nawait updateSubmissionsWithoutStatus();// Création d'une requête de base\nlet formQuery=formSubmissionsCollection;// Application des filtres si nécessaire\nif(filters){// Filtrer par statut\nif(filters.status){console.log(`[getFormSubmissions] Filtrage par statut: ${filters.status}`);formQuery=query(formQuery,where('status','==',filters.status));}// Filtrer par programmateur\nif(filters.programmerId){console.log(`[getFormSubmissions] Filtrage par programmateur: ${filters.programmerId}`);formQuery=query(formQuery,where('programmerId','==',filters.programmerId));}// Filtrer par concert\nif(filters.concertId){console.log(`[getFormSubmissions] Filtrage par concert: ${filters.concertId}`);formQuery=query(formQuery,where('concertId','==',filters.concertId));}// Filtrer par lien de formulaire\nif(filters.formLinkId){console.log(`[getFormSubmissions] Filtrage par lien de formulaire: ${filters.formLinkId}`);formQuery=query(formQuery,where('formLinkId','==',filters.formLinkId));}// Filtrer par token commun\nif(filters.commonToken){console.log(`[getFormSubmissions] Filtrage par token commun: ${filters.commonToken}`);formQuery=query(formQuery,where('commonToken','==',filters.commonToken));}}// Ajout d'un tri par date de soumission (du plus récent au plus ancien)\nformQuery=query(formQuery,orderBy('submittedAt','desc'));// Exécution de la requête\nconst snapshot=await getDocs(formQuery);if(snapshot.empty){console.log(\"[getFormSubmissions] Aucun formulaire trouvé avec les filtres spécifiés\");return[];}const formSubmissions=snapshot.docs.map(doc=>({id:doc.id,...doc.data()}));console.log(`[getFormSubmissions] ${formSubmissions.length} formulaires récupérés depuis Firebase`);formSubmissions.forEach(form=>{console.log(`[getFormSubmissions] Formulaire ID: ${form.id}, Token: ${form.commonToken}, Status: ${form.status}`);});return formSubmissions;}catch(error){console.error(\"[getFormSubmissions] Erreur lors de la récupération des formulaires:\",error);return[];}};/**\n * Met à jour les soumissions sans statut défini\n * @returns {Promise<number>} Nombre de soumissions mises à jour\n */export const updateSubmissionsWithoutStatus=async()=>{try{console.log(\"[updateSubmissionsWithoutStatus] Recherche de formulaires sans statut défini...\");// Récupérer tous les formulaires\nconst allFormsSnapshot=await getDocs(formSubmissionsCollection);if(allFormsSnapshot.empty){console.log(\"[updateSubmissionsWithoutStatus] Aucun formulaire trouvé\");return 0;}// Compter les formulaires par statut\nconst statusMap={};const formsWithoutStatus=[];allFormsSnapshot.docs.forEach(doc=>{const data=doc.data();const status=data.status||'non défini';statusMap[status]=(statusMap[status]||0)+1;if(!data.status||data.status==='non défini'){formsWithoutStatus.push({id:doc.id,...data});}});console.log(\"[updateSubmissionsWithoutStatus] Distribution des statuts:\",statusMap);// Si des formulaires sans statut sont trouvés, les mettre à jour\nif(formsWithoutStatus.length>0){console.log(`[updateSubmissionsWithoutStatus] ${formsWithoutStatus.length} formulaires sans statut trouvés, mise à jour...`);// Mettre à jour les formulaires sans statut\nfor(const form of formsWithoutStatus){console.log(`[updateSubmissionsWithoutStatus] Mise à jour du statut pour le formulaire ${form.id}`);await updateDoc(doc(db,FORM_SUBMISSIONS_COLLECTION,form.id),{status:'pending'});}console.log(`[updateSubmissionsWithoutStatus] ${formsWithoutStatus.length} formulaires mis à jour avec statut 'pending'`);return formsWithoutStatus.length;}console.log(\"[updateSubmissionsWithoutStatus] Aucun formulaire sans statut trouvé\");return 0;}catch(error){console.error(\"[updateSubmissionsWithoutStatus] Erreur lors de la mise à jour des formulaires sans statut:\",error);return 0;}};/**\n * Récupère un formulaire soumis par son ID\n * @param {string} id - ID du formulaire\n * @returns {Promise<Object>} Données du formulaire\n */export const getFormSubmissionById=async id=>{try{// S'assurer que la collection existe\nawait ensureCollection(FORM_SUBMISSIONS_COLLECTION);console.log(`[getFormSubmissionById] Tentative de récupération du formulaire ${id} depuis Firebase...`);const docRef=doc(db,FORM_SUBMISSIONS_COLLECTION,id);const snapshot=await getDoc(docRef);if(snapshot.exists()){const formData={id:snapshot.id,...snapshot.data()};// Vérifier si le statut est défini, sinon le mettre à jour\nif(!formData.status){console.log(`[getFormSubmissionById] Le formulaire ${id} n'a pas de statut défini, mise à jour à 'pending'`);await updateDoc(docRef,{status:'pending'});formData.status='pending';}console.log(`[getFormSubmissionById] Formulaire ${id} récupéré depuis Firebase:`,formData);return formData;}console.log(`[getFormSubmissionById] Formulaire ${id} non trouvé dans Firebase`);return null;}catch(error){console.error(`[getFormSubmissionById] Erreur lors de la récupération du formulaire ${id}:`,error);return null;}};/**\n * Crée un nouveau formulaire soumis\n * @param {Object} formData - Données du formulaire\n * @returns {Promise<Object>} Formulaire créé avec ID\n */export const createFormSubmission=async formData=>{console.log(\"[createFormSubmission] Début de la création d'un nouveau formulaire\");console.log(\"[createFormSubmission] Données reçues:\",formData);try{// S'assurer que la collection existe\nconsole.log(\"[createFormSubmission] Vérification de l'existence de la collection...\");const collectionExists=await ensureCollection(FORM_SUBMISSIONS_COLLECTION);console.log(`[createFormSubmission] Résultat de la vérification: ${collectionExists?'collection existe':'échec de la vérification'}`);// Vérifier les champs obligatoires\nconst requiredFields=['concertId'];const missingFields=requiredFields.filter(field=>!formData[field]);if(missingFields.length>0){console.error(`[createFormSubmission] Champs obligatoires manquants: ${missingFields.join(', ')}`);throw new Error(`Champs obligatoires manquants: ${missingFields.join(', ')}`);}// Générer un token commun si non fourni\nlet commonToken=formData.commonToken;if(!commonToken){// Importer dynamiquement pour éviter les dépendances circulaires\nconst{generateToken}=await import('../utils/tokenGenerator');commonToken=generateToken(formData.concertId);console.log(`[createFormSubmission] Génération d'un nouveau token commun: ${commonToken}`);}// S'assurer que les champs obligatoires sont présents et que le statut est explicitement défini\nconst completeFormData={...formData,commonToken,// Ajouter le token commun\nstatus:'pending',// Forcer le statut à 'pending' pour garantir la cohérence\nsubmittedAt:Timestamp.fromDate(new Date()),// Convertir la date du concert en Timestamp si elle existe\nconcertDate:formData.concertDate?formData.concertDate instanceof Date?Timestamp.fromDate(formData.concertDate):formData.concertDate:null};console.log(\"[createFormSubmission] Tentative d'ajout d'un formulaire à Firebase avec addDoc:\",completeFormData);console.log(\"[createFormSubmission] Vérification de la présence de concertId:\",completeFormData.concertId?'Présent':'Manquant');console.log(\"[createFormSubmission] Vérification de la présence du token commun:\",completeFormData.commonToken?'Présent':'Manquant');console.log(\"[createFormSubmission] Vérification du statut:\",completeFormData.status);try{const docRef=await addDoc(formSubmissionsCollection,completeFormData);console.log(`[createFormSubmission] Formulaire ajouté avec succès via addDoc, ID: ${docRef.id}`);// Vérifier immédiatement que le document a été créé avec le bon statut\nconst createdDoc=await getDoc(docRef);if(createdDoc.exists()){const createdData=createdDoc.data();console.log(`[createFormSubmission] Vérification du document créé - Statut: ${createdData.status}`);// Si le statut n'est pas 'pending', le corriger immédiatement\nif(createdData.status!=='pending'){console.log(`[createFormSubmission] Correction du statut à 'pending' pour le document ${docRef.id}`);await updateDoc(docRef,{status:'pending'});}}return{id:docRef.id,...completeFormData};}catch(addDocError){console.error(\"[createFormSubmission] Erreur lors de l'ajout du formulaire avec addDoc:\",addDocError);// Essayer d'ajouter le formulaire avec un ID généré manuellement\nconsole.log(\"[createFormSubmission] Tentative alternative avec setDoc...\");const mockId='form-'+Date.now();try{await setDoc(doc(db,FORM_SUBMISSIONS_COLLECTION,mockId),completeFormData);console.log(`[createFormSubmission] Formulaire ajouté avec succès via setDoc, ID: ${mockId}`);// Vérifier immédiatement que le document a été créé avec le bon statut\nconst createdDoc=await getDoc(doc(db,FORM_SUBMISSIONS_COLLECTION,mockId));if(createdDoc.exists()){const createdData=createdDoc.data();console.log(`[createFormSubmission] Vérification du document créé - Statut: ${createdData.status}`);// Si le statut n'est pas 'pending', le corriger immédiatement\nif(createdData.status!=='pending'){console.log(`[createFormSubmission] Correction du statut à 'pending' pour le document ${mockId}`);await updateDoc(doc(db,FORM_SUBMISSIONS_COLLECTION,mockId),{status:'pending'});}}return{id:mockId,...completeFormData};}catch(setDocError){console.error(\"[createFormSubmission] Erreur lors de l'ajout du formulaire avec setDoc:\",setDocError);throw setDocError;// Propager l'erreur pour la gestion dans le composant\n}}}catch(error){console.error(\"[createFormSubmission] Erreur générale lors de l'ajout du formulaire:\",error);// Vérifier si l'erreur est liée à un champ manquant\nif(error.message&&error.message.includes('Champs obligatoires manquants')){throw error;// Propager l'erreur spécifique\n}throw error;}};/**\n * Met à jour un formulaire soumis existant\n * @param {string} id - ID du formulaire\n * @param {Object} formData - Nouvelles données du formulaire\n * @returns {Promise<Object>} Formulaire mis à jour\n */export const updateFormSubmission=async(id,formData)=>{try{// S'assurer que la collection existe\nawait ensureCollection(FORM_SUBMISSIONS_COLLECTION);console.log(`[updateFormSubmission] Tentative de mise à jour du formulaire ${id}:`,formData);const docRef=doc(db,FORM_SUBMISSIONS_COLLECTION,id);// Si le statut change à 'processed' ou 'rejected', ajouter la date de traitement\nconst updatedData={...formData};if(formData.status==='processed'||formData.status==='rejected'){updatedData.processedAt=Timestamp.fromDate(new Date());}// Convertir la date du concert en Timestamp si elle existe\nif(formData.concertDate){updatedData.concertDate=formData.concertDate instanceof Date?Timestamp.fromDate(formData.concertDate):formData.concertDate;}await updateDoc(docRef,updatedData);console.log(`[updateFormSubmission] Formulaire ${id} mis à jour avec succès`);return{id,...updatedData};}catch(error){console.error(`[updateFormSubmission] Erreur lors de la mise à jour du formulaire ${id}:`,error);throw error;}};/**\n * Supprime un formulaire soumis\n * @param {string} id - ID du formulaire\n * @returns {Promise<boolean>} Succès de la suppression\n */export const deleteFormSubmission=async id=>{try{// S'assurer que la collection existe\nawait ensureCollection(FORM_SUBMISSIONS_COLLECTION);console.log(`[deleteFormSubmission] Tentative de suppression du formulaire ${id}`);const docRef=doc(db,FORM_SUBMISSIONS_COLLECTION,id);await deleteDoc(docRef);console.log(`[deleteFormSubmission] Formulaire ${id} supprimé avec succès`);return true;}catch(error){console.error(`[deleteFormSubmission] Erreur lors de la suppression du formulaire ${id}:`,error);throw error;}};/**\n * Récupère les formulaires soumis par un programmateur\n * @param {string} programmerId - ID du programmateur\n * @returns {Promise<Array>} Liste des formulaires soumis\n */export const getFormSubmissionsByProgrammer=async programmerId=>{return getFormSubmissions({programmerId});};/**\n * Récupère les formulaires soumis par statut\n * @param {string} status - Statut des formulaires\n * @returns {Promise<Array>} Liste des formulaires soumis\n */export const getFormSubmissionsByStatus=async status=>{return getFormSubmissions({status});};/**\n * Récupère les formulaires soumis pour un concert\n * @param {string} concertId - ID du concert\n * @returns {Promise<Array>} Liste des formulaires soumis\n */export const getFormSubmissionsByConcert=async concertId=>{return getFormSubmissions({concertId});};/**\n * Récupère les formulaires soumis par token commun\n * @param {string} commonToken - Token commun\n * @returns {Promise<Array>} Liste des formulaires soumis\n */export const getFormSubmissionsByToken=async commonToken=>{return getFormSubmissions({commonToken});};/**\n * Récupère un formulaire soumis par son ID de lien\n * @param {string} formLinkId - ID du lien de formulaire\n * @returns {Promise<Object>} Formulaire soumis\n */export const getFormSubmissionByFormLinkId=async formLinkId=>{try{const submissions=await getFormSubmissions({formLinkId});return submissions.length>0?submissions[0]:null;}catch(error){console.error(`[getFormSubmissionByFormLinkId] Erreur lors de la récupération du formulaire avec formLinkId ${formLinkId}:`,error);throw error;}};","map":{"version":3,"names":["collection","getDocs","getDoc","doc","addDoc","updateDoc","deleteDoc","query","orderBy","where","setDoc","Timestamp","limit","db","FORM_SUBMISSIONS_COLLECTION","ensureCollection","collectionName","console","log","collectionRef","snapshot","empty","size","error","formSubmissionsCollection","getFormSubmissions","filters","arguments","length","undefined","updateSubmissionsWithoutStatus","formQuery","status","programmerId","concertId","formLinkId","commonToken","formSubmissions","docs","map","id","data","forEach","form","allFormsSnapshot","statusMap","formsWithoutStatus","push","getFormSubmissionById","docRef","exists","formData","createFormSubmission","collectionExists","requiredFields","missingFields","filter","field","join","Error","generateToken","completeFormData","submittedAt","fromDate","Date","concertDate","createdDoc","createdData","addDocError","mockId","now","setDocError","message","includes","updateFormSubmission","updatedData","processedAt","deleteFormSubmission","getFormSubmissionsByProgrammer","getFormSubmissionsByStatus","getFormSubmissionsByConcert","getFormSubmissionsByToken","getFormSubmissionByFormLinkId","submissions"],"sources":["/workspaces/app-booking/client/src/services/formSubmissionsService.js"],"sourcesContent":["import { \n  collection, \n  getDocs, \n  getDoc, \n  doc, \n  addDoc, \n  updateDoc, \n  deleteDoc,\n  query,\n  orderBy,\n  where,\n  setDoc,\n  Timestamp,\n  limit\n} from 'firebase/firestore';\nimport { db } from '../firebase';\n\n// Collection de référence\nconst FORM_SUBMISSIONS_COLLECTION = 'formSubmissions';\n\n// Assurez-vous que la collection existe\nconst ensureCollection = async (collectionName) => {\n  try {\n    console.log(`[ensureCollection] Vérification de la collection ${collectionName}...`);\n    \n    // Vérifier si la collection existe en essayant de récupérer des documents\n    const collectionRef = collection(db, collectionName);\n    const snapshot = await getDocs(query(collectionRef, limit(1)));\n    \n    console.log(`[ensureCollection] Résultat de la vérification: ${snapshot.empty ? 'collection vide' : snapshot.size + ' documents trouvés'}`);\n    \n    return true;\n  } catch (error) {\n    console.error(`[ensureCollection] Erreur lors de la vérification de la collection ${collectionName}:`, error);\n    return false;\n  }\n};\n\n// Assurez-vous que la collection formSubmissions existe\nconst formSubmissionsCollection = collection(db, FORM_SUBMISSIONS_COLLECTION);\n\n/**\n * Récupère tous les formulaires soumis\n * @param {Object} filters - Filtres à appliquer (optionnel)\n * @returns {Promise<Array>} Liste des formulaires soumis\n */\nexport const getFormSubmissions = async (filters = {}) => {\n  try {\n    // S'assurer que la collection existe\n    await ensureCollection(FORM_SUBMISSIONS_COLLECTION);\n    \n    console.log(\"[getFormSubmissions] Tentative de récupération des formulaires depuis Firebase...\");\n    console.log(\"[getFormSubmissions] Filtres appliqués:\", filters);\n    \n    // Vérifier et mettre à jour les soumissions sans statut\n    await updateSubmissionsWithoutStatus();\n    \n    // Création d'une requête de base\n    let formQuery = formSubmissionsCollection;\n    \n    // Application des filtres si nécessaire\n    if (filters) {\n      // Filtrer par statut\n      if (filters.status) {\n        console.log(`[getFormSubmissions] Filtrage par statut: ${filters.status}`);\n        formQuery = query(formQuery, where('status', '==', filters.status));\n      }\n      \n      // Filtrer par programmateur\n      if (filters.programmerId) {\n        console.log(`[getFormSubmissions] Filtrage par programmateur: ${filters.programmerId}`);\n        formQuery = query(formQuery, where('programmerId', '==', filters.programmerId));\n      }\n      \n      // Filtrer par concert\n      if (filters.concertId) {\n        console.log(`[getFormSubmissions] Filtrage par concert: ${filters.concertId}`);\n        formQuery = query(formQuery, where('concertId', '==', filters.concertId));\n      }\n      \n      // Filtrer par lien de formulaire\n      if (filters.formLinkId) {\n        console.log(`[getFormSubmissions] Filtrage par lien de formulaire: ${filters.formLinkId}`);\n        formQuery = query(formQuery, where('formLinkId', '==', filters.formLinkId));\n      }\n      \n      // Filtrer par token commun\n      if (filters.commonToken) {\n        console.log(`[getFormSubmissions] Filtrage par token commun: ${filters.commonToken}`);\n        formQuery = query(formQuery, where('commonToken', '==', filters.commonToken));\n      }\n    }\n    \n    // Ajout d'un tri par date de soumission (du plus récent au plus ancien)\n    formQuery = query(formQuery, orderBy('submittedAt', 'desc'));\n    \n    // Exécution de la requête\n    const snapshot = await getDocs(formQuery);\n    \n    if (snapshot.empty) {\n      console.log(\"[getFormSubmissions] Aucun formulaire trouvé avec les filtres spécifiés\");\n      return [];\n    }\n    \n    const formSubmissions = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    console.log(`[getFormSubmissions] ${formSubmissions.length} formulaires récupérés depuis Firebase`);\n    formSubmissions.forEach(form => {\n      console.log(`[getFormSubmissions] Formulaire ID: ${form.id}, Token: ${form.commonToken}, Status: ${form.status}`);\n    });\n    \n    return formSubmissions;\n  } catch (error) {\n    console.error(\"[getFormSubmissions] Erreur lors de la récupération des formulaires:\", error);\n    return [];\n  }\n};\n\n/**\n * Met à jour les soumissions sans statut défini\n * @returns {Promise<number>} Nombre de soumissions mises à jour\n */\nexport const updateSubmissionsWithoutStatus = async () => {\n  try {\n    console.log(\"[updateSubmissionsWithoutStatus] Recherche de formulaires sans statut défini...\");\n    \n    // Récupérer tous les formulaires\n    const allFormsSnapshot = await getDocs(formSubmissionsCollection);\n    if (allFormsSnapshot.empty) {\n      console.log(\"[updateSubmissionsWithoutStatus] Aucun formulaire trouvé\");\n      return 0;\n    }\n    \n    // Compter les formulaires par statut\n    const statusMap = {};\n    const formsWithoutStatus = [];\n    \n    allFormsSnapshot.docs.forEach(doc => {\n      const data = doc.data();\n      const status = data.status || 'non défini';\n      statusMap[status] = (statusMap[status] || 0) + 1;\n      \n      if (!data.status || data.status === 'non défini') {\n        formsWithoutStatus.push({\n          id: doc.id,\n          ...data\n        });\n      }\n    });\n    \n    console.log(\"[updateSubmissionsWithoutStatus] Distribution des statuts:\", statusMap);\n    \n    // Si des formulaires sans statut sont trouvés, les mettre à jour\n    if (formsWithoutStatus.length > 0) {\n      console.log(`[updateSubmissionsWithoutStatus] ${formsWithoutStatus.length} formulaires sans statut trouvés, mise à jour...`);\n      \n      // Mettre à jour les formulaires sans statut\n      for (const form of formsWithoutStatus) {\n        console.log(`[updateSubmissionsWithoutStatus] Mise à jour du statut pour le formulaire ${form.id}`);\n        await updateDoc(doc(db, FORM_SUBMISSIONS_COLLECTION, form.id), {\n          status: 'pending'\n        });\n      }\n      \n      console.log(`[updateSubmissionsWithoutStatus] ${formsWithoutStatus.length} formulaires mis à jour avec statut 'pending'`);\n      return formsWithoutStatus.length;\n    }\n    \n    console.log(\"[updateSubmissionsWithoutStatus] Aucun formulaire sans statut trouvé\");\n    return 0;\n  } catch (error) {\n    console.error(\"[updateSubmissionsWithoutStatus] Erreur lors de la mise à jour des formulaires sans statut:\", error);\n    return 0;\n  }\n};\n\n/**\n * Récupère un formulaire soumis par son ID\n * @param {string} id - ID du formulaire\n * @returns {Promise<Object>} Données du formulaire\n */\nexport const getFormSubmissionById = async (id) => {\n  try {\n    // S'assurer que la collection existe\n    await ensureCollection(FORM_SUBMISSIONS_COLLECTION);\n    \n    console.log(`[getFormSubmissionById] Tentative de récupération du formulaire ${id} depuis Firebase...`);\n    const docRef = doc(db, FORM_SUBMISSIONS_COLLECTION, id);\n    const snapshot = await getDoc(docRef);\n    \n    if (snapshot.exists()) {\n      const formData = {\n        id: snapshot.id,\n        ...snapshot.data()\n      };\n      \n      // Vérifier si le statut est défini, sinon le mettre à jour\n      if (!formData.status) {\n        console.log(`[getFormSubmissionById] Le formulaire ${id} n'a pas de statut défini, mise à jour à 'pending'`);\n        await updateDoc(docRef, { status: 'pending' });\n        formData.status = 'pending';\n      }\n      \n      console.log(`[getFormSubmissionById] Formulaire ${id} récupéré depuis Firebase:`, formData);\n      return formData;\n    }\n    \n    console.log(`[getFormSubmissionById] Formulaire ${id} non trouvé dans Firebase`);\n    return null;\n  } catch (error) {\n    console.error(`[getFormSubmissionById] Erreur lors de la récupération du formulaire ${id}:`, error);\n    return null;\n  }\n};\n\n/**\n * Crée un nouveau formulaire soumis\n * @param {Object} formData - Données du formulaire\n * @returns {Promise<Object>} Formulaire créé avec ID\n */\nexport const createFormSubmission = async (formData) => {\n  console.log(\"[createFormSubmission] Début de la création d'un nouveau formulaire\");\n  console.log(\"[createFormSubmission] Données reçues:\", formData);\n  \n  try {\n    // S'assurer que la collection existe\n    console.log(\"[createFormSubmission] Vérification de l'existence de la collection...\");\n    const collectionExists = await ensureCollection(FORM_SUBMISSIONS_COLLECTION);\n    console.log(`[createFormSubmission] Résultat de la vérification: ${collectionExists ? 'collection existe' : 'échec de la vérification'}`);\n    \n    // Vérifier les champs obligatoires\n    const requiredFields = ['concertId'];\n    const missingFields = requiredFields.filter(field => !formData[field]);\n    \n    if (missingFields.length > 0) {\n      console.error(`[createFormSubmission] Champs obligatoires manquants: ${missingFields.join(', ')}`);\n      throw new Error(`Champs obligatoires manquants: ${missingFields.join(', ')}`);\n    }\n    \n    // Générer un token commun si non fourni\n    let commonToken = formData.commonToken;\n    if (!commonToken) {\n      // Importer dynamiquement pour éviter les dépendances circulaires\n      const { generateToken } = await import('../utils/tokenGenerator');\n      commonToken = generateToken(formData.concertId);\n      console.log(`[createFormSubmission] Génération d'un nouveau token commun: ${commonToken}`);\n    }\n    \n    // S'assurer que les champs obligatoires sont présents et que le statut est explicitement défini\n    const completeFormData = {\n      ...formData,\n      commonToken, // Ajouter le token commun\n      status: 'pending', // Forcer le statut à 'pending' pour garantir la cohérence\n      submittedAt: Timestamp.fromDate(new Date()),\n      // Convertir la date du concert en Timestamp si elle existe\n      concertDate: formData.concertDate ? \n        (formData.concertDate instanceof Date ? \n          Timestamp.fromDate(formData.concertDate) : \n          formData.concertDate) : \n        null\n    };\n    \n    console.log(\"[createFormSubmission] Tentative d'ajout d'un formulaire à Firebase avec addDoc:\", completeFormData);\n    console.log(\"[createFormSubmission] Vérification de la présence de concertId:\", completeFormData.concertId ? 'Présent' : 'Manquant');\n    console.log(\"[createFormSubmission] Vérification de la présence du token commun:\", completeFormData.commonToken ? 'Présent' : 'Manquant');\n    console.log(\"[createFormSubmission] Vérification du statut:\", completeFormData.status);\n    \n    try {\n      const docRef = await addDoc(formSubmissionsCollection, completeFormData);\n      console.log(`[createFormSubmission] Formulaire ajouté avec succès via addDoc, ID: ${docRef.id}`);\n      \n      // Vérifier immédiatement que le document a été créé avec le bon statut\n      const createdDoc = await getDoc(docRef);\n      if (createdDoc.exists()) {\n        const createdData = createdDoc.data();\n        console.log(`[createFormSubmission] Vérification du document créé - Statut: ${createdData.status}`);\n        \n        // Si le statut n'est pas 'pending', le corriger immédiatement\n        if (createdData.status !== 'pending') {\n          console.log(`[createFormSubmission] Correction du statut à 'pending' pour le document ${docRef.id}`);\n          await updateDoc(docRef, { status: 'pending' });\n        }\n      }\n      \n      return {\n        id: docRef.id,\n        ...completeFormData\n      };\n    } catch (addDocError) {\n      console.error(\"[createFormSubmission] Erreur lors de l'ajout du formulaire avec addDoc:\", addDocError);\n      \n      // Essayer d'ajouter le formulaire avec un ID généré manuellement\n      console.log(\"[createFormSubmission] Tentative alternative avec setDoc...\");\n      const mockId = 'form-' + Date.now();\n      \n      try {\n        await setDoc(doc(db, FORM_SUBMISSIONS_COLLECTION, mockId), completeFormData);\n        console.log(`[createFormSubmission] Formulaire ajouté avec succès via setDoc, ID: ${mockId}`);\n        \n        // Vérifier immédiatement que le document a été créé avec le bon statut\n        const createdDoc = await getDoc(doc(db, FORM_SUBMISSIONS_COLLECTION, mockId));\n        if (createdDoc.exists()) {\n          const createdData = createdDoc.data();\n          console.log(`[createFormSubmission] Vérification du document créé - Statut: ${createdData.status}`);\n          \n          // Si le statut n'est pas 'pending', le corriger immédiatement\n          if (createdData.status !== 'pending') {\n            console.log(`[createFormSubmission] Correction du statut à 'pending' pour le document ${mockId}`);\n            await updateDoc(doc(db, FORM_SUBMISSIONS_COLLECTION, mockId), { status: 'pending' });\n          }\n        }\n        \n        return {\n          id: mockId,\n          ...completeFormData\n        };\n      } catch (setDocError) {\n        console.error(\"[createFormSubmission] Erreur lors de l'ajout du formulaire avec setDoc:\", setDocError);\n        throw setDocError; // Propager l'erreur pour la gestion dans le composant\n      }\n    }\n  } catch (error) {\n    console.error(\"[createFormSubmission] Erreur générale lors de l'ajout du formulaire:\", error);\n    \n    // Vérifier si l'erreur est liée à un champ manquant\n    if (error.message && error.message.includes('Champs obligatoires manquants')) {\n      throw error; // Propager l'erreur spécifique\n    }\n    \n    throw error;\n  }\n};\n\n/**\n * Met à jour un formulaire soumis existant\n * @param {string} id - ID du formulaire\n * @param {Object} formData - Nouvelles données du formulaire\n * @returns {Promise<Object>} Formulaire mis à jour\n */\nexport const updateFormSubmission = async (id, formData) => {\n  try {\n    // S'assurer que la collection existe\n    await ensureCollection(FORM_SUBMISSIONS_COLLECTION);\n    \n    console.log(`[updateFormSubmission] Tentative de mise à jour du formulaire ${id}:`, formData);\n    const docRef = doc(db, FORM_SUBMISSIONS_COLLECTION, id);\n    \n    // Si le statut change à 'processed' ou 'rejected', ajouter la date de traitement\n    const updatedData = {\n      ...formData\n    };\n    \n    if (formData.status === 'processed' || formData.status === 'rejected') {\n      updatedData.processedAt = Timestamp.fromDate(new Date());\n    }\n    \n    // Convertir la date du concert en Timestamp si elle existe\n    if (formData.concertDate) {\n      updatedData.concertDate = formData.concertDate instanceof Date ? \n        Timestamp.fromDate(formData.concertDate) : \n        formData.concertDate;\n    }\n    \n    await updateDoc(docRef, updatedData);\n    console.log(`[updateFormSubmission] Formulaire ${id} mis à jour avec succès`);\n    \n    return {\n      id,\n      ...updatedData\n    };\n  } catch (error) {\n    console.error(`[updateFormSubmission] Erreur lors de la mise à jour du formulaire ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Supprime un formulaire soumis\n * @param {string} id - ID du formulaire\n * @returns {Promise<boolean>} Succès de la suppression\n */\nexport const deleteFormSubmission = async (id) => {\n  try {\n    // S'assurer que la collection existe\n    await ensureCollection(FORM_SUBMISSIONS_COLLECTION);\n    \n    console.log(`[deleteFormSubmission] Tentative de suppression du formulaire ${id}`);\n    const docRef = doc(db, FORM_SUBMISSIONS_COLLECTION, id);\n    await deleteDoc(docRef);\n    console.log(`[deleteFormSubmission] Formulaire ${id} supprimé avec succès`);\n    \n    return true;\n  } catch (error) {\n    console.error(`[deleteFormSubmission] Erreur lors de la suppression du formulaire ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Récupère les formulaires soumis par un programmateur\n * @param {string} programmerId - ID du programmateur\n * @returns {Promise<Array>} Liste des formulaires soumis\n */\nexport const getFormSubmissionsByProgrammer = async (programmerId) => {\n  return getFormSubmissions({ programmerId });\n};\n\n/**\n * Récupère les formulaires soumis par statut\n * @param {string} status - Statut des formulaires\n * @returns {Promise<Array>} Liste des formulaires soumis\n */\nexport const getFormSubmissionsByStatus = async (status) => {\n  return getFormSubmissions({ status });\n};\n\n/**\n * Récupère les formulaires soumis pour un concert\n * @param {string} concertId - ID du concert\n * @returns {Promise<Array>} Liste des formulaires soumis\n */\nexport const getFormSubmissionsByConcert = async (concertId) => {\n  return getFormSubmissions({ concertId });\n};\n\n/**\n * Récupère les formulaires soumis par token commun\n * @param {string} commonToken - Token commun\n * @returns {Promise<Array>} Liste des formulaires soumis\n */\nexport const getFormSubmissionsByToken = async (commonToken) => {\n  return getFormSubmissions({ commonToken });\n};\n\n/**\n * Récupère un formulaire soumis par son ID de lien\n * @param {string} formLinkId - ID du lien de formulaire\n * @returns {Promise<Object>} Formulaire soumis\n */\nexport const getFormSubmissionByFormLinkId = async (formLinkId) => {\n  try {\n    const submissions = await getFormSubmissions({ formLinkId });\n    return submissions.length > 0 ? submissions[0] : null;\n  } catch (error) {\n    console.error(`[getFormSubmissionByFormLinkId] Erreur lors de la récupération du formulaire avec formLinkId ${formLinkId}:`, error);\n    throw error;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}